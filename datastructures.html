<!DOCTYPE html>
<html class="writer-html5" lang="ru">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>datastructures package &mdash; документация Python Algorithms and Datastructures </title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=ddbc6389"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="_static/translations.js?v=29b1f277"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="next" title="algorithms package" href="algorithms.html" />
    <link rel="prev" title="Modules" href="modules.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Python Algorithms and Datastructures
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Поиск в документации" aria-label="Поиск в документации" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Меню навигации">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="modules.html">Modules</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">datastructures package</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#module-datastructures.linearDataStructures">datastructures.linearDataStructures module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedListNode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue"><code class="docutils literal notranslate"><span class="pre">Queue</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack"><code class="docutils literal notranslate"><span class="pre">Stack</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray"><code class="docutils literal notranslate"><span class="pre">StaticArray</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#module-datastructures.binaryTrees">datastructures.binaryTrees module</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST"><code class="docutils literal notranslate"><span class="pre">BST</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode"><code class="docutils literal notranslate"><span class="pre">BSTNode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTree"><code class="docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT"><code class="docutils literal notranslate"><span class="pre">SQT</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode"><code class="docutils literal notranslate"><span class="pre">SQTNode</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.height"><code class="docutils literal notranslate"><span class="pre">height()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="algorithms.html">algorithms package</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Меню навигации для мобильных устройств" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Python Algorithms and Datastructures</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Навигация по страницам">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="modules.html">Modules</a></li>
      <li class="breadcrumb-item active">datastructures package</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/datastructures.rst.txt" rel="nofollow"> Просмотреть исходный код страницы</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="datastructures-package">
<h1>datastructures package<a class="headerlink" href="#datastructures-package" title="Permalink to this heading"></a></h1>
<section id="module-datastructures.linearDataStructures">
<span id="datastructures-lineardatastructures-module"></span><h2>datastructures.linearDataStructures module<a class="headerlink" href="#module-datastructures.linearDataStructures" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">DoublyLinkedList</span></span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a></p>
<p>Список связан двойными узлами (<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode" title="datastructures.linearDataStructures.DoublyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedListNode</span></code></a>):
они хранят указатели как на предыдущий узел, так и на следующий.</p>
<img alt="_images/doubly-linked-list.png" src="_images/doubly-linked-list.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.build" title="Ссылка на это определение"></a></dt>
<dd><p>Преобразует входящий список в LinkedList.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>datalist</strong> – обычный список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.consists">
<span class="sig-name descname"><span class="pre">consists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.consists" title="Ссылка на это определение"></a></dt>
<dd><p>Содержит ли список узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True - если содержит, иначе False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет узел на i-ой позиции.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>~O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить данные i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>~O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс позиции нового узла</p></li>
<li><p><strong>data</strong> – данные нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на 0-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на последнюю позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>индекс узла, либо -1, если узел не найден</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Меняет данные на data в i-ом узле.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – устанавливаемые данные</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">DoublyLinkedListNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="datastructures.linearDataStructures.SinglyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a></p>
<p>Этот класс представляет собой узел двойного связанного списка (<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>).
Он занимает в два раза больше памяти, потому что имеет указатель как и на следующий, так и на предыдущий узел.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация узла</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – данные, которые хранит узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.earlier_node">
<span class="sig-name descname"><span class="pre">earlier_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.earlier_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка от конца до начала.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности <strong>от конца</strong></p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности <strong>от конца</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.later_node">
<span class="sig-name descname"><span class="pre">later_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.later_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка. От начала до конца.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">Queue</span></span><a class="headerlink" href="#datastructures.linearDataStructures.Queue" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p><strong>First in - First out</strong> список (FIFO). Альтернативное название: очередь. Работает так же, как очередь в пивнушке.</p>
<a class="reference internal image-reference" href="_images/queue.png"><img alt="_images/queue.png" src="_images/queue.png" style="width: 400px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Очередь работает с помощью <a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>,
чтобы всё работало со сложностью алгоритма <strong>O(1)</strong>, вместо O(n). Такое решение было принято в связи с тем,
что очереди работают на <em>сдвигах</em> и с <em>крайними элементами списка</em>. Если вы хотите работать с очередью как
просто со списком, обращайтесь к параметру <cite>data</cite>: там находится
<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>, на котором всё работает.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.dequeue">
<span class="sig-name descname"><span class="pre">dequeue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.dequeue" title="Ссылка на это определение"></a></dt>
<dd><p>Вынуть из очереди следующий (первый) элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение элемента, которого мы вынимаем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.enqueue">
<span class="sig-name descname"><span class="pre">enqueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.enqueue" title="Ссылка на это определение"></a></dt>
<dd><p>Поставить в очередь предмет.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Значение элемента очереди, который мы ставим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.peek_back">
<span class="sig-name descname"><span class="pre">peek_back</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.peek_back" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать последний элемент очереди. Он же хвост, он же конечный элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний элемент очереди</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.peek_front">
<span class="sig-name descname"><span class="pre">peek_front</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.peek_front" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать первый элемент очереди. Он же голова, он же следующий элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый элемент очереди</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">SinglyLinkedList</span></span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Список связан единичными узлами (<a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="datastructures.linearDataStructures.SinglyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a>): они хранят указатели <strong>только</strong> на следующий узел.</p>
<img alt="_images/singly-linked-list.png" src="_images/singly-linked-list.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.build" title="Ссылка на это определение"></a></dt>
<dd><p>Преобразует входящий список в LinkedList.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>datalist</strong> – обычный список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.consists">
<span class="sig-name descname"><span class="pre">consists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.consists" title="Ссылка на это определение"></a></dt>
<dd><p>Содержит ли список узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True - если содержит, иначе False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет узел на i-ой позиции.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить данные i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс позиции нового узла</p></li>
<li><p><strong>data</strong> – данные нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на 0-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Добавляет узел в конец списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – данные нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>индекс узла, либо -1, если узел не найден</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Меняет данные на data в i-ом узле.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – устанавливаемые данные</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">SinglyLinkedListNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Этот класс представляет собой узел связанного списка (<a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>).</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация узла</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – данные, которые хранит узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode.later_node">
<span class="sig-name descname"><span class="pre">later_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode.later_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка. От начала до конца.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">Stack</span></span><a class="headerlink" href="#datastructures.linearDataStructures.Stack" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p><strong>Last in - First out</strong> список (LIFO). Альтернативное название: стак/стэк. Работает так же, как и стопка тарелок.</p>
<a class="reference internal image-reference" href="_images/stack.png"><img alt="_images/stack.png" src="_images/stack.png" style="width: 400px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Стак работает с помощью <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>,
чтобы всё работало со сложностью алгоритма <strong>O(1)</strong>, вместо O(n). Такое решение было принято в связи с тем,
что стаки работают на <em>сдвигах</em> и с <em>крайними элементами списка</em>. Если вы хотите работать со
стаком как просто со списком, обращайтесь к параметру <cite>data</cite>:
там находится <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>, на котором всё работает.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.peek">
<span class="sig-name descname"><span class="pre">peek</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.peek" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать верхний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение верхнего элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.peek_bottom">
<span class="sig-name descname"><span class="pre">peek_bottom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.peek_bottom" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать нижний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение нижнего элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.pop" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет верхний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Верхний элемент, который мы удаляем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.push" title="Ссылка на это определение"></a></dt>
<dd><p>Положить наверх стопки новый элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Значение элемента, которого мы хотим положить наверх стопки</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">StaticArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Обычный нерасширяемый список</p>
<a class="reference internal image-reference" href="_images/static-array.png"><img alt="_images/static-array.png" src="_images/static-array.png" style="width: 300px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация статичного списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> – Длина списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – Индекс элемента</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Данные под i-ым индексом</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск данных.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Искомые данные</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс искомых данных</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Установить значение элемента.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – Индекс элемента</p></li>
<li><p><strong>item</strong> – Значение элемента</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-datastructures.binaryTrees">
<span id="datastructures-binarytrees-module"></span><h2>datastructures.binaryTrees module<a class="headerlink" href="#module-datastructures.binaryTrees" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BST</span></span><a class="headerlink" href="#datastructures.binaryTrees.BST" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTree" title="datastructures.binaryTrees.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор дерева с типом узлов <a class="reference internal" href="#datastructures.binaryTrees.BSTNode" title="datastructures.binaryTrees.BSTNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BSTNode</span></code></a>.
Это то же самое бинарное дерево, но значения узлов будут возрастать в порядке обхода.
Повторяющиеся элементы пропадают. По другому это дерево можно назвать бинарное дерево-множество или
дерево бинарного поиска.</p>
<a class="reference internal image-reference" href="_images/bst.png"><img alt="_images/bst.png" src="_images/bst.png" style="width: 500px;" /></a>
<p>Если обойти это дерево по порядку (<a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a>),
то на выходе мы получим узлы в порядке возрастания:
<strong>2 4 6 8 9 10 11 12 14 16 18</strong></p>
<img alt="_images/BST_complexity.png" src="_images/BST_complexity.png" />
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.build" title="Ссылка на это определение"></a></dt>
<dd><p>Строит дерево бинарного поиска из входящего списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(nlog n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr</strong> – входящий список значений узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.delete" title="Ссылка на это определение"></a></dt>
<dd><p>Удалить узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение удаляемого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_max">
<span class="sig-name descname"><span class="pre">find_max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_max" title="Ссылка на это определение"></a></dt>
<dd><p>Максимальный элемент - последний, поэтому вызываем <a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_last" title="datastructures.binaryTrees.BSTNode.subtree_last"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_last</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение максимального узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_min">
<span class="sig-name descname"><span class="pre">find_min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_min" title="Ссылка на это определение"></a></dt>
<dd><p>Минимальный элемент - первый, поэтому вызываем <a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_first" title="datastructures.binaryTrees.BSTNode.subtree_first"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_first</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение минимального узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_next">
<span class="sig-name descname"><span class="pre">find_next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_next" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент, идущий после данного.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение элемента, после которого идёт искомый</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_prev">
<span class="sig-name descname"><span class="pre">find_prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_prev" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент, идущий перед данным.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение элемента, перед которым идёт искомый</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.binaryTrees.BST.insert" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение нового узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>True</em>, если узел был добавлен, иначе <em>False</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BSTNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find">
<span class="sig-name descname"><span class="pre">subtree_find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">TreeNodeType</span></span></span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find" title="Ссылка на это определение"></a></dt>
<dd><p>Найти узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>искомый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find_next">
<span class="sig-name descname"><span class="pre">subtree_find_next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find_next" title="Ссылка на это определение"></a></dt>
<dd><p>Найти следующий узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение, после которого идет значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>узел, значение которого идёт после входного значения</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find_prev">
<span class="sig-name descname"><span class="pre">subtree_find_prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find_prev" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предыдущий узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение, перед которым идет значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>узел, значение которого идёт перед входным значением</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert">
<span class="sig-name descname"><span class="pre">subtree_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert" title="Ссылка на это определение"></a></dt>
<dd><p>Добавить новый узел и не нарушить порядок возрастания при обходе по порядку.</p>
<img alt="_images/bst_insert.gif" src="_images/bst_insert.gif" />
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_node</strong> – новый узел, который мы добавляем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal).
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла. <em>Высота самого высокого ребёнка + 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BinaryTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TreeNodeType=&lt;class</span> <span class="pre">'datastructures.binaryTrees.BinaryTreeNode'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTree" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Бинарное дерево AVL. Дерево называется бинарным, потому что у каждого узла не может быть более чем 2 ребёнка.
AVL значит, что дерево автоматически <em>балансируется</em> (читай далее), что позволяет сократить сложность выполнения
большинства алгоритмов с O(n) или O(h) до <strong>O(log n)</strong>!</p>
<a class="reference internal image-reference" href="_images/binary-tree.png"><img alt="_images/binary-tree.png" src="_images/binary-tree.png" style="width: 500px;" /></a>
<dl class="simple">
<dt>Немного терминологии:</dt><dd><ul class="simple">
<li><p>Узел - элемент дерева</p></li>
<li><p>Корень - самый верхний элемент, из которого идет всё дерево</p></li>
<li><p>Лист - узел без детей</p></li>
<li><p>Поддерево - дерево внутри другого дерева.</p></li>
<li><p>Ребёнок - один из узлов, выходящих из определённого</p></li>
<li><p>Родитель - узел, из которого выходит определённый</p></li>
<li><p>Грань - связь между ребёнком и родителем</p></li>
<li><p>Предшественник - тот, кто идёт раньше определённого узла по порядку обхода в глубину in order <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a></p></li>
<li><p>Преемник - тот, кто идёт позже определённого узла по порядку обхода в глубину in order <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a></p></li>
</ul>
</dd>
<dt>Типы деревьев:</dt><dd><ul class="simple">
<li><p>Полное: у каждого узла либо 0, либо 2 ребёнка.</p></li>
<li><p>Дегенеративное: у каждого узла либо 0, либо 1 ребёнок</p></li>
<li><p>Перекошенное: дегенеративное дерево, у узлов которого есть либо <strong>только</strong> правый ребёнок или нет ребёнка, либо <strong>только</strong> левый ребёнок или нет ребёнка</p></li>
<li><p>Полное: все слои дереве, кроме, возможно, последнего, полностью заполнены</p></li>
<li><p>Идеальное: полное дерево, у которого все листья на одном уровне</p></li>
<li><p>Сбалансированное: дерево, у которого разница между высотой левого и правого поддерева меньше или равна 1</p></li>
</ul>
</dd>
</dl>
<section id="avl">
<h3><strong>В этих таблицах вы можете видеть преимущество AVL деревьев:</strong><a class="headerlink" href="#avl" title="Permalink to this heading"></a></h3>
<img alt="_images/BST_complexity.png" src="_images/BST_complexity.png" />
<img alt="_images/SQT_complexity.png" src="_images/SQT_complexity.png" />
<p><strong>Эти типы деревьев я вынес в отдельные классы</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTree.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TreeNodeType=&lt;class</span> <span class="pre">'datastructures.binaryTrees.BinaryTreeNode'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTree.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>TreeNodeType</strong> – Тип узлов дерева. По умолчанию <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BinaryTreeNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal).
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла. <em>Высота самого высокого ребёнка + 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">SQT</span></span><a class="headerlink" href="#datastructures.binaryTrees.SQT" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTree" title="datastructures.binaryTrees.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></p>
<p>Бинарное дерево, к элементам которого можно обращаться по индексу (<em>Sequence Binary Tree</em>).
<strong>Индексация идет по порядку обхода дерева</strong>.</p>
<img alt="_images/SQT_complexity.png" src="_images/SQT_complexity.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>TreeNodeType</strong> – Тип узлов дерева. По умолчанию <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.build" title="Ссылка на это определение"></a></dt>
<dd><p>Построить дерево из входящего списка. Но алгоритм не просто поочерёдно вставлять элементы,
а корнем каждого поддерева является центр среза входящего списка, что способствует балансу дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>datalist</strong> – входящий список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет i-ый элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс удаляемого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить i-ый узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс нового узла</p></li>
<li><p><strong>data</strong> – значение нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел в начало дерева (0 позиция).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – значение нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел в конец дерева (len(self) позиция).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – значение нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Установить значение i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – новое значение узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">SQTNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
<p>Индексируемый узел имеет параметр размера. Размер – это сумма размеров детей + 1.
Это нужно для индексации узлов.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_at">
<span class="sig-name descname"><span class="pre">subtree_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_at" title="Ссылка на это определение"></a></dt>
<dd><p>Найти i-ый узел. Поиск происходит через размеры узлов:</p>
<ul class="simple">
<li><p>Если размер левого ребёнка больше индекса, найти i-ый узел в левом поддереве.</p></li>
<li><p>Если размер левого ребёнка меньше индекса, найти узел в правом поддереве с индексом: <em>индекс - размер левого ребёнка - 1</em>.</p></li>
<li><p>Если размер левого ребенка равен индексу, вернуть текущий узел.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>искомый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal).
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла (<em>высота самого высокого ребёнка + 1</em>)
и размер (<em>это сумма размеров детей + 1</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.binaryTrees.height">
<span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">height</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#datastructures.binaryTrees.height" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает высоту входящего узла. Сложность алгоритма является <strong>O(1)</strong>
вместо O(h), потому что каждый узел хранит в себе значение его высоты.
При каждом изменении дерева это значение обновляется при необходимости.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – узел, высоту которого надо узнать</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>высота узла и, если узла нет, -1</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Нижняя область">
        <a href="modules.html" class="btn btn-neutral float-left" title="Modules" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Предыдущая</a>
        <a href="algorithms.html" class="btn btn-neutral float-right" title="algorithms package" accesskey="n" rel="next">Следующая <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Авторские права 2023, zhukovrost. </p>
  </div>

  Собрано при помощи <a href="https://www.sphinx-doc.org/">Sphinx</a> с использованием
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">темы,</a>
    предоставленной <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>