<!DOCTYPE html>
<html class="writer-html5" lang="ru">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Modules &mdash; документация Python Algorithms and Datastructures </title>
      <link rel="stylesheet" type="text/css" href="_static/pygments.css?v=80d5e7a1" />
      <link rel="stylesheet" type="text/css" href="_static/css/theme.css?v=19f00094" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script src="_static/jquery.js?v=5d32c60e"></script>
        <script src="_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
        <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js?v=ddbc6389"></script>
        <script src="_static/doctools.js?v=888ff710"></script>
        <script src="_static/sphinx_highlight.js?v=4825356b"></script>
        <script src="_static/translations.js?v=29b1f277"></script>
    <script src="_static/js/theme.js"></script>
    <link rel="index" title="Алфавитный указатель" href="genindex.html" />
    <link rel="search" title="Поиск" href="search.html" />
    <link rel="prev" title="Welcome to Python DataStructures by slav_EEik documentation!" href="index.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="index.html" class="icon icon-home">
            Python Algorithms and Datastructures
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Поиск в документации" aria-label="Поиск в документации" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Меню навигации">
              <p class="caption" role="heading"><span class="caption-text">Contents:</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="current reference internal" href="#">Modules</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#module-datastructures.sorts">datastructures.sorts module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.sorts.bubble_sort"><code class="docutils literal notranslate"><span class="pre">bubble_sort()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.sorts.heap_sort"><code class="docutils literal notranslate"><span class="pre">heap_sort()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.sorts.partition"><code class="docutils literal notranslate"><span class="pre">partition()</span></code></a></li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.sorts.quicksort"><code class="docutils literal notranslate"><span class="pre">quicksort()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-datastructures.linearDataStructures">datastructures.linearDataStructures module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.Deque"><code class="docutils literal notranslate"><span class="pre">Deque</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.__init__"><code class="docutils literal notranslate"><span class="pre">Deque.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.dequeue"><code class="docutils literal notranslate"><span class="pre">Deque.dequeue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.enqueue"><code class="docutils literal notranslate"><span class="pre">Deque.enqueue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.peek_back"><code class="docutils literal notranslate"><span class="pre">Deque.peek_back()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.peek_front"><code class="docutils literal notranslate"><span class="pre">Deque.peek_front()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.pop"><code class="docutils literal notranslate"><span class="pre">Deque.pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.pop_back"><code class="docutils literal notranslate"><span class="pre">Deque.pop_back()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.pop_front"><code class="docutils literal notranslate"><span class="pre">Deque.pop_front()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.push"><code class="docutils literal notranslate"><span class="pre">Deque.push()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.push_back"><code class="docutils literal notranslate"><span class="pre">Deque.push_back()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Deque.push_front"><code class="docutils literal notranslate"><span class="pre">Deque.push_front()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.__init__"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.build"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.consists"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.consists()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_at"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.delete_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_first"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.delete_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_last"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.delete_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.get_at"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.get_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_at"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.insert_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_first"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.insert_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_last"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.insert_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.search"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.search()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList.set_at"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedList.set_at()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedListNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode.__init__"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedListNode.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode.earlier_node"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedListNode.earlier_node()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode.later_node"><code class="docutils literal notranslate"><span class="pre">DoublyLinkedListNode.later_node()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.Queue"><code class="docutils literal notranslate"><span class="pre">Queue</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.__init__"><code class="docutils literal notranslate"><span class="pre">Queue.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.dequeue"><code class="docutils literal notranslate"><span class="pre">Queue.dequeue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.enqueue"><code class="docutils literal notranslate"><span class="pre">Queue.enqueue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.peek_back"><code class="docutils literal notranslate"><span class="pre">Queue.peek_back()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.peek_front"><code class="docutils literal notranslate"><span class="pre">Queue.peek_front()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.pop"><code class="docutils literal notranslate"><span class="pre">Queue.pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Queue.push"><code class="docutils literal notranslate"><span class="pre">Queue.push()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.__init__"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.build"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.consists"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.consists()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_at"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.delete_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_first"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.delete_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_last"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.delete_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.get_at"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.get_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_at"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.insert_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_first"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.insert_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_last"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.insert_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.search"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.search()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList.set_at"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedList.set_at()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode.__init__"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedListNode.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode.later_node"><code class="docutils literal notranslate"><span class="pre">SinglyLinkedListNode.later_node()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.Stack"><code class="docutils literal notranslate"><span class="pre">Stack</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack.__init__"><code class="docutils literal notranslate"><span class="pre">Stack.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack.peek"><code class="docutils literal notranslate"><span class="pre">Stack.peek()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack.peek_bottom"><code class="docutils literal notranslate"><span class="pre">Stack.peek_bottom()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack.pop"><code class="docutils literal notranslate"><span class="pre">Stack.pop()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.Stack.push"><code class="docutils literal notranslate"><span class="pre">Stack.push()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray"><code class="docutils literal notranslate"><span class="pre">StaticArray</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray.__init__"><code class="docutils literal notranslate"><span class="pre">StaticArray.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray.get_at"><code class="docutils literal notranslate"><span class="pre">StaticArray.get_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray.search"><code class="docutils literal notranslate"><span class="pre">StaticArray.search()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.linearDataStructures.StaticArray.set_at"><code class="docutils literal notranslate"><span class="pre">StaticArray.set_at()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-datastructures.binaryTrees">datastructures.binaryTrees module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.BST"><code class="docutils literal notranslate"><span class="pre">BST</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.__init__"><code class="docutils literal notranslate"><span class="pre">BST.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.build"><code class="docutils literal notranslate"><span class="pre">BST.build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.delete"><code class="docutils literal notranslate"><span class="pre">BST.delete()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.find"><code class="docutils literal notranslate"><span class="pre">BST.find()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.find_max"><code class="docutils literal notranslate"><span class="pre">BST.find_max()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.find_min"><code class="docutils literal notranslate"><span class="pre">BST.find_min()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.find_next"><code class="docutils literal notranslate"><span class="pre">BST.find_next()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.find_prev"><code class="docutils literal notranslate"><span class="pre">BST.find_prev()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BST.insert"><code class="docutils literal notranslate"><span class="pre">BST.insert()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode"><code class="docutils literal notranslate"><span class="pre">BSTNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.__init__"><code class="docutils literal notranslate"><span class="pre">BSTNode.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.inorder_traversal"><code class="docutils literal notranslate"><span class="pre">BSTNode.inorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.level_order_traversal"><code class="docutils literal notranslate"><span class="pre">BSTNode.level_order_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.maintain"><code class="docutils literal notranslate"><span class="pre">BSTNode.maintain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.postorder_traversal"><code class="docutils literal notranslate"><span class="pre">BSTNode.postorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.predecessor"><code class="docutils literal notranslate"><span class="pre">BSTNode.predecessor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.preorder_traversal"><code class="docutils literal notranslate"><span class="pre">BSTNode.preorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.rebalance"><code class="docutils literal notranslate"><span class="pre">BSTNode.rebalance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.skew"><code class="docutils literal notranslate"><span class="pre">BSTNode.skew()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_delete"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_delete()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_find"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_find()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_find_next"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_find_next()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_find_prev"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_find_prev()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_first"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_insert"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_insert()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_insert_after"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_insert_after()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_insert_before"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_insert_before()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_iter"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_iter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_last"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_left"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_rotate_left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_right"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_rotate_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_update"><code class="docutils literal notranslate"><span class="pre">BSTNode.subtree_update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BSTNode.successor"><code class="docutils literal notranslate"><span class="pre">BSTNode.successor()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTree"><code class="docutils literal notranslate"><span class="pre">BinaryTree</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTree.__init__"><code class="docutils literal notranslate"><span class="pre">BinaryTree.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.__init__"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.inorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.level_order_traversal"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.level_order_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.maintain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.postorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.predecessor"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.predecessor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.preorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.rebalance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.skew"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.skew()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_delete"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_delete()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_first"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_after"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_insert_after()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_before"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_insert_before()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_iter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_last"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_left"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_rotate_left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_right"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_rotate_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.subtree_update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.successor"><code class="docutils literal notranslate"><span class="pre">BinaryTreeNode.successor()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.SQT"><code class="docutils literal notranslate"><span class="pre">SQT</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.__init__"><code class="docutils literal notranslate"><span class="pre">SQT.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.build"><code class="docutils literal notranslate"><span class="pre">SQT.build()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.delete_at"><code class="docutils literal notranslate"><span class="pre">SQT.delete_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.delete_first"><code class="docutils literal notranslate"><span class="pre">SQT.delete_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.delete_last"><code class="docutils literal notranslate"><span class="pre">SQT.delete_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.get_at"><code class="docutils literal notranslate"><span class="pre">SQT.get_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.insert_at"><code class="docutils literal notranslate"><span class="pre">SQT.insert_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.insert_first"><code class="docutils literal notranslate"><span class="pre">SQT.insert_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.insert_last"><code class="docutils literal notranslate"><span class="pre">SQT.insert_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQT.set_at"><code class="docutils literal notranslate"><span class="pre">SQT.set_at()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode"><code class="docutils literal notranslate"><span class="pre">SQTNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.__init__"><code class="docutils literal notranslate"><span class="pre">SQTNode.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.inorder_traversal"><code class="docutils literal notranslate"><span class="pre">SQTNode.inorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.level_order_traversal"><code class="docutils literal notranslate"><span class="pre">SQTNode.level_order_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.maintain"><code class="docutils literal notranslate"><span class="pre">SQTNode.maintain()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.postorder_traversal"><code class="docutils literal notranslate"><span class="pre">SQTNode.postorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.predecessor"><code class="docutils literal notranslate"><span class="pre">SQTNode.predecessor()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.preorder_traversal"><code class="docutils literal notranslate"><span class="pre">SQTNode.preorder_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.rebalance"><code class="docutils literal notranslate"><span class="pre">SQTNode.rebalance()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.skew"><code class="docutils literal notranslate"><span class="pre">SQTNode.skew()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_at"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_at()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_delete"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_delete()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_first"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_first()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_insert_after"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_insert_after()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_insert_before"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_insert_before()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_iter"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_iter()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_last"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_last()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_left"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_rotate_left()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_right"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_rotate_right()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.subtree_update"><code class="docutils literal notranslate"><span class="pre">SQTNode.subtree_update()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.binaryTrees.SQTNode.successor"><code class="docutils literal notranslate"><span class="pre">SQTNode.successor()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.binaryTrees.height"><code class="docutils literal notranslate"><span class="pre">height()</span></code></a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-datastructures.heap">datastructures.heap module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.heap.MinHeap"><code class="docutils literal notranslate"><span class="pre">MinHeap</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.__init__"><code class="docutils literal notranslate"><span class="pre">MinHeap.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.add"><code class="docutils literal notranslate"><span class="pre">MinHeap.add()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.count"><code class="docutils literal notranslate"><span class="pre">MinHeap.count()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.get_item"><code class="docutils literal notranslate"><span class="pre">MinHeap.get_item()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.get_left_child_index"><code class="docutils literal notranslate"><span class="pre">MinHeap.get_left_child_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.get_parent_index"><code class="docutils literal notranslate"><span class="pre">MinHeap.get_parent_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.get_right_child_index"><code class="docutils literal notranslate"><span class="pre">MinHeap.get_right_child_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.has_left_child"><code class="docutils literal notranslate"><span class="pre">MinHeap.has_left_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.has_parent"><code class="docutils literal notranslate"><span class="pre">MinHeap.has_parent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.has_right_child"><code class="docutils literal notranslate"><span class="pre">MinHeap.has_right_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.heapify_down"><code class="docutils literal notranslate"><span class="pre">MinHeap.heapify_down()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.heapify_up"><code class="docutils literal notranslate"><span class="pre">MinHeap.heapify_up()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.left_child"><code class="docutils literal notranslate"><span class="pre">MinHeap.left_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.parent"><code class="docutils literal notranslate"><span class="pre">MinHeap.parent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.peek"><code class="docutils literal notranslate"><span class="pre">MinHeap.peek()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.poll"><code class="docutils literal notranslate"><span class="pre">MinHeap.poll()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.MinHeap.right_child"><code class="docutils literal notranslate"><span class="pre">MinHeap.right_child()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.heap.PriorityQueue"><code class="docutils literal notranslate"><span class="pre">PriorityQueue</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.__init__"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.add"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.add()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.count"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.count()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.dequeue"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.dequeue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.enqueue"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.enqueue()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.get_item"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.get_item()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.get_left_child_index"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.get_left_child_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.get_parent_index"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.get_parent_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.get_right_child_index"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.get_right_child_index()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.has_left_child"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.has_left_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.has_parent"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.has_parent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.has_right_child"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.has_right_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.heapify_down"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.heapify_down()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.heapify_up"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.heapify_up()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.left_child"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.left_child()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.parent"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.parent()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.peek"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.peek()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.poll"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.poll()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueue.right_child"><code class="docutils literal notranslate"><span class="pre">PriorityQueue.right_child()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.heap.PriorityQueueNode"><code class="docutils literal notranslate"><span class="pre">PriorityQueueNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.heap.PriorityQueueNode.__init__"><code class="docutils literal notranslate"><span class="pre">PriorityQueueNode.__init__()</span></code></a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#module-datastructures.graphs">datastructures.graphs module</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.graphs.GraphNode"><code class="docutils literal notranslate"><span class="pre">GraphNode</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphNode.__init__"><code class="docutils literal notranslate"><span class="pre">GraphNode.__init__()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.graphs.GraphParent"><code class="docutils literal notranslate"><span class="pre">GraphParent</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.__init__"><code class="docutils literal notranslate"><span class="pre">GraphParent.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.add_edge"><code class="docutils literal notranslate"><span class="pre">GraphParent.add_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.breadth_first_traversal"><code class="docutils literal notranslate"><span class="pre">GraphParent.breadth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.depth_first_traversal"><code class="docutils literal notranslate"><span class="pre">GraphParent.depth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.print_adjacency"><code class="docutils literal notranslate"><span class="pre">GraphParent.print_adjacency()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.remove_edge"><code class="docutils literal notranslate"><span class="pre">GraphParent.remove_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.shortest_path"><code class="docutils literal notranslate"><span class="pre">GraphParent.shortest_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.GraphParent.traversal"><code class="docutils literal notranslate"><span class="pre">GraphParent.traversal()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.graphs.ListAdjacency"><code class="docutils literal notranslate"><span class="pre">ListAdjacency</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.__init__"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.add_edge"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.add_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.breadth_first_traversal"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.breadth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.depth_first_traversal"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.depth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.print_adjacency"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.print_adjacency()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.remove_edge"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.remove_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.shortest_path"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.shortest_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.ListAdjacency.traversal"><code class="docutils literal notranslate"><span class="pre">ListAdjacency.traversal()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency</span></code></a><ul>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.__init__"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.__init__()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.add_edge"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.add_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.breadth_first_traversal"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.breadth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.depth_first_traversal"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.depth_first_traversal()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.print_adjacency"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.print_adjacency()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.remove_edge"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.remove_edge()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.shortest_path"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.shortest_path()</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#datastructures.graphs.MatrixAdjacency.traversal"><code class="docutils literal notranslate"><span class="pre">MatrixAdjacency.traversal()</span></code></a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="#datastructures.graphs.get_path"><code class="docutils literal notranslate"><span class="pre">get_path()</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Меню навигации для мобильных устройств" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Python Algorithms and Datastructures</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Навигация по страницам">
  <ul class="wy-breadcrumbs">
      <li><a href="index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Modules</li>
      <li class="wy-breadcrumbs-aside">
            <a href="_sources/modules.rst.txt" rel="nofollow"> Просмотреть исходный код страницы</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="modules">
<h1>Modules<a class="headerlink" href="#modules" title="Permalink to this heading"></a></h1>
<div class="toctree-wrapper compound">
</div>
<section id="module-datastructures.sorts">
<span id="datastructures-sorts-module"></span><h2>datastructures.sorts module<a class="headerlink" href="#module-datastructures.sorts" title="Permalink to this heading"></a></h2>
<dl class="py function">
<dt class="sig sig-object py" id="datastructures.sorts.bubble_sort">
<span class="sig-prename descclassname"><span class="pre">datastructures.sorts.</span></span><span class="sig-name descname"><span class="pre">bubble_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.sorts.bubble_sort" title="Ссылка на это определение"></a></dt>
<dd><p>Сортировка пузырьком.</p>
<img alt="_images/bubble-sort.gif" src="_images/bubble-sort.gif" />
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(N^2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>arr</strong> – Список, который требуется отсортировать.</p></li>
<li><p><strong>kwargs</strong> – <p>Дополнительные параметры для настройки поведения сортировки.
Возможные параметры:</p>
<ul>
<li><p>reverse (bool): Если установлено в True, возвращает список в обратном порядке.</p></li>
<li><p>inplace (bool): Если установлено в True, сортирует список на месте (in-place).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Отсортированный список.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.sorts.heap_sort">
<span class="sig-prename descclassname"><span class="pre">datastructures.sorts.</span></span><span class="sig-name descname"><span class="pre">heap_sort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.sorts.heap_sort" title="Ссылка на это определение"></a></dt>
<dd><p>Сортирует входной список с использованием алгоритма сортировки кучей.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(N log N)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>arr</strong> – Список, который требуется отсортировать.</p></li>
<li><p><strong>kwargs</strong> – <p>Дополнительные параметры для настройки поведения сортировки.
Возможные параметры:</p>
<ul>
<li><p>reverse (bool): Если установлено в True, возвращает список в обратном порядке.</p></li>
<li><p>inplace (bool): Если установлено в True, сортирует список на месте (in-place).</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Отсортированный список.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.sorts.partition">
<span class="sig-prename descclassname"><span class="pre">datastructures.sorts.</span></span><span class="sig-name descname"><span class="pre">partition</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">reverse</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.sorts.partition" title="Ссылка на это определение"></a></dt>
<dd><p>Эта функция реализует логику разделения для алгоритма быстрой сортировки.
Она выбирает последний элемент в качестве опорного и переставляет массив так,
чтобы все элементы меньше опорного были слева, а все элементы больше опорного - справа,
либо наоборот, если reverse == True.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>arr</strong> – Список для сортировки.</p></li>
<li><p><strong>left</strong> – Начальный индекс подсписка для сортировки.</p></li>
<li><p><strong>right</strong> – Конечный индекс подсписка для сортировки.</p></li>
<li><p><strong>reverse</strong> – Если True, сортирует список в обратном порядке. Если False, сортирует в прямом порядке.</p></li>
</ul>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Индекс опорного элемента после разделения.</p>
</dd>
</dl>
</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.sorts.quicksort">
<span class="sig-prename descclassname"><span class="pre">datastructures.sorts.</span></span><span class="sig-name descname"><span class="pre">quicksort</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">left</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">right</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.sorts.quicksort" title="Ссылка на это определение"></a></dt>
<dd><p>Выполняет алгоритм быстрой сортировки на входном списке.</p>
<img alt="_images/quicksort.gif" src="_images/quicksort.gif" />
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(N log N)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>arr</strong> – Список для сортировки.</p></li>
<li><p><strong>left</strong> – Начальный индекс подсписка для сортировки. По умолчанию 0.</p></li>
<li><p><strong>right</strong> – Конечный индекс подсписка для сортировки. По умолчанию len(arr) - 1.</p></li>
<li><p><strong>kwargs</strong> – <p>Дополнительные параметры для поведения сортировки.</p>
<ul>
<li><p>inplace (bool): Если True, сортирует список на месте. По умолчанию False.</p></li>
<li><p>reverse (bool): Если True, сортирует список в обратном порядке. По умолчанию False.</p></li>
</ul>
</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Отсортированный список.</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-datastructures.linearDataStructures">
<span id="datastructures-lineardatastructures-module"></span><h2>datastructures.linearDataStructures module<a class="headerlink" href="#module-datastructures.linearDataStructures" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">Deque</span></span><a class="headerlink" href="#datastructures.linearDataStructures.Deque" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.linearDataStructures.Queue" title="datastructures.linearDataStructures.Queue"><code class="xref py py-class docutils literal notranslate"><span class="pre">Queue</span></code></a></p>
<p>Двусторонняя очередь.</p>
<img alt="_images/deque.jpg" src="_images/deque.jpg" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Очередь работает с помощью <a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>,
чтобы всё работало со сложностью алгоритма <strong>O(1)</strong>, вместо O(n). Такое решение было принято в связи с тем,
что очереди работают на <em>сдвигах</em> и с <em>крайними элементами списка</em>. Если вы хотите работать с очередью как
просто со списком, обращайтесь к параметру <cite>data</cite>: там находится
<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>, на котором всё работает.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.dequeue">
<span class="sig-name descname"><span class="pre">dequeue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.dequeue" title="Ссылка на это определение"></a></dt>
<dd><p><strong>Для работы как с обычной очередью:</strong> вынуть из очереди следующий (первый) элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение элемента, которого мы вынимаем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.enqueue">
<span class="sig-name descname"><span class="pre">enqueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.enqueue" title="Ссылка на это определение"></a></dt>
<dd><p><strong>Для работы как с обычной очередью:</strong> поставить в очередь предмет. (Сделать последним элементом <em>item</em>)</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Значение элемента очереди, который мы ставим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.peek_back">
<span class="sig-name descname"><span class="pre">peek_back</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.peek_back" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать последний элемент очереди. Он же хвост, он же конечный элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний элемент очереди</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.peek_front">
<span class="sig-name descname"><span class="pre">peek_front</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.peek_front" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать первый элемент очереди. Он же голова, он же следующий элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый элемент очереди</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.pop" title="Ссылка на это определение"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.pop_back">
<span class="sig-name descname"><span class="pre">pop_back</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.pop_back" title="Ссылка на это определение"></a></dt>
<dd><p>Выбрасывает из очереди последний элемент по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение выбрасываемого элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.pop_front">
<span class="sig-name descname"><span class="pre">pop_front</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.pop_front" title="Ссылка на это определение"></a></dt>
<dd><p>Выбрасывает из очереди первый элемент по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение выбрасываемого элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.push" title="Ссылка на это определение"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.push_back">
<span class="sig-name descname"><span class="pre">push_back</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.push_back" title="Ссылка на это определение"></a></dt>
<dd><p>Поставить новый элемент в конец по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение нового элемента.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Deque.push_front">
<span class="sig-name descname"><span class="pre">push_front</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Deque.push_front" title="Ссылка на это определение"></a></dt>
<dd><p>Поставить новый элемент в начало по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение нового элемента.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">DoublyLinkedList</span></span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a></p>
<p>Список связан двойными узлами (<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedListNode" title="datastructures.linearDataStructures.DoublyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedListNode</span></code></a>):
они хранят указатели как на предыдущий узел, так и на следующий.</p>
<img alt="_images/doubly-linked-list.png" src="_images/doubly-linked-list.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.build" title="Ссылка на это определение"></a></dt>
<dd><p>Преобразует входящий список в LinkedList.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>datalist</strong> – обычный список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.consists">
<span class="sig-name descname"><span class="pre">consists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.consists" title="Ссылка на это определение"></a></dt>
<dd><p>Содержит ли список узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True - если содержит, иначе False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет узел на i-ой позиции.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>~O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить данные i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>~O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс позиции нового узла</p></li>
<li><p><strong>data</strong> – данные нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на 0-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на последнюю позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>индекс узла, либо -1, если узел не найден</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedList.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedList.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Меняет данные на data в i-ом узле.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i/2)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – устанавливаемые данные</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">DoublyLinkedListNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="datastructures.linearDataStructures.SinglyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a></p>
<p>Этот класс представляет собой узел двойного связанного списка (<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>).
Он занимает в два раза больше памяти, потому что имеет указатель как и на следующий, так и на предыдущий узел.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация узла</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – данные, которые хранит узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.earlier_node">
<span class="sig-name descname"><span class="pre">earlier_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.earlier_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка от конца до начала.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности <strong>от конца</strong></p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности <strong>от конца</strong></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.DoublyLinkedListNode.later_node">
<span class="sig-name descname"><span class="pre">later_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.DoublyLinkedListNode.later_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка. От начала до конца.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">Queue</span></span><a class="headerlink" href="#datastructures.linearDataStructures.Queue" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p><strong>First in - First out</strong> список (FIFO). Альтернативное название: очередь. Работает так же, как очередь в пивнушке.</p>
<a class="reference internal image-reference" href="_images/queue.png"><img alt="_images/queue.png" src="_images/queue.png" style="width: 400px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Очередь работает с помощью <a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>,
чтобы всё работало со сложностью алгоритма <strong>O(1)</strong>, вместо O(n). Такое решение было принято в связи с тем,
что очереди работают на <em>сдвигах</em> и с <em>крайними элементами списка</em>. Если вы хотите работать с очередью как
просто со списком, обращайтесь к параметру <cite>data</cite>: там находится
<a class="reference internal" href="#datastructures.linearDataStructures.DoublyLinkedList" title="datastructures.linearDataStructures.DoublyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">DoublyLinkedList</span></code></a>, на котором всё работает.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.dequeue">
<span class="sig-name descname"><span class="pre">dequeue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.dequeue" title="Ссылка на это определение"></a></dt>
<dd><p>Вынуть из очереди следующий (первый) элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение элемента, которого мы вынимаем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.enqueue">
<span class="sig-name descname"><span class="pre">enqueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.enqueue" title="Ссылка на это определение"></a></dt>
<dd><p>Поставить в очередь предмет. (Сделать последним элементом <em>item</em>)</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Значение элемента очереди, который мы ставим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.peek_back">
<span class="sig-name descname"><span class="pre">peek_back</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.peek_back" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать последний элемент очереди. Он же хвост, он же конечный элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний элемент очереди</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.peek_front">
<span class="sig-name descname"><span class="pre">peek_front</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.peek_front" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать первый элемент очереди. Он же голова, он же следующий элемент очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый элемент очереди</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.pop" title="Ссылка на это определение"></a></dt>
<dd></dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Queue.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Queue.push" title="Ссылка на это определение"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">SinglyLinkedList</span></span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Список связан единичными узлами (<a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="datastructures.linearDataStructures.SinglyLinkedListNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedListNode</span></code></a>): они хранят указатели <strong>только</strong> на следующий узел.</p>
<img alt="_images/singly-linked-list.png" src="_images/singly-linked-list.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">datalist</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.build" title="Ссылка на это определение"></a></dt>
<dd><p>Преобразует входящий список в LinkedList.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>datalist</strong> – обычный список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.consists">
<span class="sig-name descname"><span class="pre">consists</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.consists" title="Ссылка на это определение"></a></dt>
<dd><p>Содержит ли список узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True - если содержит, иначе False</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет узел на i-ой позиции.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>удаляемый узел списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>данные удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить данные i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>данные искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс позиции нового узла</p></li>
<li><p><strong>data</strong> – данные нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет узел на 0-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – Данные, которые будут вставлены в список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Добавляет узел в конец списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – данные нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>индекс узла, либо -1, если узел не найден</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedList.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedList.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Меняет данные на data в i-ом узле.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – устанавливаемые данные</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">SinglyLinkedListNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Этот класс представляет собой узел связанного списка (<a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>).</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация узла</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>data</strong> – данные, которые хранит узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.SinglyLinkedListNode.later_node">
<span class="sig-name descname"><span class="pre">later_node</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.SinglyLinkedListNode.later_node" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция обхода списка. От начала до конца.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(i)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – номер узла последовательности</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>i-ый узел последовательности</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">Stack</span></span><a class="headerlink" href="#datastructures.linearDataStructures.Stack" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p><strong>Last in - First out</strong> список (LIFO). Альтернативное название: стак/стэк. Работает так же, как и стопка тарелок.</p>
<a class="reference internal image-reference" href="_images/stack.png"><img alt="_images/stack.png" src="_images/stack.png" style="width: 400px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Стак работает с помощью <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>,
чтобы всё работало со сложностью алгоритма <strong>O(1)</strong>, вместо O(n). Такое решение было принято в связи с тем,
что стаки работают на <em>сдвигах</em> и с <em>крайними элементами списка</em>. Если вы хотите работать со
стаком как просто со списком, обращайтесь к параметру <cite>data</cite>:
там находится <a class="reference internal" href="#datastructures.linearDataStructures.SinglyLinkedList" title="datastructures.linearDataStructures.SinglyLinkedList"><code class="xref py py-class docutils literal notranslate"><span class="pre">SinglyLinkedList</span></code></a>, на котором всё работает.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.peek">
<span class="sig-name descname"><span class="pre">peek</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.peek" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать верхний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение верхнего элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.peek_bottom">
<span class="sig-name descname"><span class="pre">peek_bottom</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.peek_bottom" title="Ссылка на это определение"></a></dt>
<dd><p>Узнать нижний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Значение нижнего элемента</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.pop">
<span class="sig-name descname"><span class="pre">pop</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.pop" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет верхний элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Верхний элемент, который мы удаляем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.Stack.push">
<span class="sig-name descname"><span class="pre">push</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.Stack.push" title="Ссылка на это определение"></a></dt>
<dd><p>Положить наверх стопки новый элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Значение элемента, которого мы хотим положить наверх стопки</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.linearDataStructures.</span></span><span class="sig-name descname"><span class="pre">StaticArray</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Обычный нерасширяемый список</p>
<a class="reference internal image-reference" href="_images/static-array.png"><img alt="_images/static-array.png" src="_images/static-array.png" style="width: 300px;" /></a>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализация статичного списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>n</strong> – Длина списка</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – Индекс элемента</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Данные под i-ым индексом</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.search">
<span class="sig-name descname"><span class="pre">search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.search" title="Ссылка на это определение"></a></dt>
<dd><p>Поиск данных.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Искомые данные</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс искомых данных</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.linearDataStructures.StaticArray.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.linearDataStructures.StaticArray.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Установить значение элемента.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – Индекс элемента</p></li>
<li><p><strong>item</strong> – Значение элемента</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
<section id="module-datastructures.binaryTrees">
<span id="datastructures-binarytrees-module"></span><h2>datastructures.binaryTrees module<a class="headerlink" href="#module-datastructures.binaryTrees" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BST</span></span><a class="headerlink" href="#datastructures.binaryTrees.BST" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTree" title="datastructures.binaryTrees.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор дерева с типом узлов <a class="reference internal" href="#datastructures.binaryTrees.BSTNode" title="datastructures.binaryTrees.BSTNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BSTNode</span></code></a>.
Это то же самое бинарное дерево, но значения узлов будут возрастать в порядке обхода.
Повторяющиеся элементы пропадают. По другому это дерево можно назвать бинарное дерево-множество или
дерево бинарного поиска.</p>
<a class="reference internal image-reference" href="_images/bst.png"><img alt="_images/bst.png" src="_images/bst.png" style="width: 500px;" /></a>
<p>Если обойти это дерево по порядку (<a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a>),
то на выходе мы получим узлы в порядке возрастания:
<strong>2 4 6 8 9 10 11 12 14 16 18</strong></p>
<img alt="_images/BST_complexity.png" src="_images/BST_complexity.png" />
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.build" title="Ссылка на это определение"></a></dt>
<dd><p>Строит дерево бинарного поиска из входящего списка.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(nlog n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr</strong> – входящий список значений узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.delete">
<span class="sig-name descname"><span class="pre">delete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.delete" title="Ссылка на это определение"></a></dt>
<dd><p>Удалить узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение удаляемого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find">
<span class="sig-name descname"><span class="pre">find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – искомое значение</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_max">
<span class="sig-name descname"><span class="pre">find_max</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_max" title="Ссылка на это определение"></a></dt>
<dd><p>Максимальный элемент - последний, поэтому вызываем <a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_last" title="datastructures.binaryTrees.BSTNode.subtree_last"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_last</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение максимального узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_min">
<span class="sig-name descname"><span class="pre">find_min</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_min" title="Ссылка на это определение"></a></dt>
<dd><p>Минимальный элемент - первый, поэтому вызываем <a class="reference internal" href="#datastructures.binaryTrees.BSTNode.subtree_first" title="datastructures.binaryTrees.BSTNode.subtree_first"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_first</span></code></a></p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение минимального узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_next">
<span class="sig-name descname"><span class="pre">find_next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_next" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент, идущий после данного.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение элемента, после которого идёт искомый</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.find_prev">
<span class="sig-name descname"><span class="pre">find_prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BST.find_prev" title="Ссылка на это определение"></a></dt>
<dd><p>Найти элемент, идущий перед данным.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение элемента, перед которым идёт искомый</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого элемента, если элемент не найден возвращает None</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BST.insert">
<span class="sig-name descname"><span class="pre">insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.binaryTrees.BST.insert" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение нового узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p><em>True</em>, если узел был добавлен, иначе <em>False</em></p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BSTNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.inorder_traversal">
<span class="sig-name descname"><span class="pre">inorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.inorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<p>Обход дерева по умолчанию (<a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a>.).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.level_order_traversal">
<span class="sig-name descname"><span class="pre">level_order_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.level_order_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход в ширину (<strong>BFS</strong> - <cite>Breadth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода в ширину:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти следующий слой</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/levelorder-traversal.gif"><img alt="_images/levelorder-traversal.gif" src="_images/levelorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.postorder_traversal">
<span class="sig-name descname"><span class="pre">postorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.postorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (postorder traversal), также <cite>обратный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм обратного обхода:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/postorder-traversal.gif"><img alt="_images/postorder-traversal.gif" src="_images/postorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.preorder_traversal">
<span class="sig-name descname"><span class="pre">preorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.preorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (preorder traversal), также <cite>прямой</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм прямого обхода:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/preorder-traversal.gif"><img alt="_images/preorder-traversal.gif" src="_images/preorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find">
<span class="sig-name descname"><span class="pre">subtree_find</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find" title="Ссылка на это определение"></a></dt>
<dd><p>Найти узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>искомый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find_next">
<span class="sig-name descname"><span class="pre">subtree_find_next</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find_next" title="Ссылка на это определение"></a></dt>
<dd><p>Найти следующий узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение, после которого идет значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>узел, значение которого идёт после входного значения</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_find_prev">
<span class="sig-name descname"><span class="pre">subtree_find_prev</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_find_prev" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предыдущий узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – значение, перед которым идет значение искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>узел, значение которого идёт перед входным значением</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert">
<span class="sig-name descname"><span class="pre">subtree_insert</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">new_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert" title="Ссылка на это определение"></a></dt>
<dd><p>Добавить новый узел и не нарушить порядок возрастания при обходе по порядку.</p>
<img alt="_images/bst_insert.gif" src="_images/bst_insert.gif" />
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>new_node</strong> – новый узел, который мы добавляем</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла. <em>Высота самого высокого ребёнка + 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BSTNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BSTNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTree">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BinaryTree</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TreeNodeType=&lt;class</span> <span class="pre">'datastructures.binaryTrees.BinaryTreeNode'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTree" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Бинарное дерево AVL. Дерево называется бинарным, потому что у каждого узла не может быть более чем 2 ребёнка.
AVL значит, что дерево автоматически <em>балансируется</em> (читай далее), что позволяет сократить сложность выполнения
большинства алгоритмов с O(n) или O(h) до <strong>O(log n)</strong>!</p>
<a class="reference internal image-reference" href="_images/binary-tree.png"><img alt="_images/binary-tree.png" src="_images/binary-tree.png" style="width: 500px;" /></a>
<dl class="simple">
<dt>Немного терминологии:</dt><dd><ul class="simple">
<li><p>Узел - элемент дерева</p></li>
<li><p>Корень - самый верхний элемент, из которого идет всё дерево</p></li>
<li><p>Лист - узел без детей</p></li>
<li><p>Поддерево - дерево внутри другого дерева.</p></li>
<li><p>Ребёнок - один из узлов, выходящих из определённого</p></li>
<li><p>Родитель - узел, из которого выходит определённый</p></li>
<li><p>Грань - связь между ребёнком и родителем</p></li>
<li><p>Предшественник - тот, кто идёт раньше определённого узла по порядку обхода в глубину in order <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a></p></li>
<li><p>Преемник - тот, кто идёт позже определённого узла по порядку обхода в глубину in order <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a></p></li>
</ul>
</dd>
<dt>Типы деревьев:</dt><dd><ul class="simple">
<li><p>Полное: у каждого узла либо 0, либо 2 ребёнка.</p></li>
<li><p>Дегенеративное: у каждого узла либо 0, либо 1 ребёнок</p></li>
<li><p>Перекошенное: дегенеративное дерево, у узлов которого есть либо <strong>только</strong> правый ребёнок или нет ребёнка, либо <strong>только</strong> левый ребёнок или нет ребёнка</p></li>
<li><p>Полное: все слои дереве, кроме, возможно, последнего, полностью заполнены</p></li>
<li><p>Идеальное: полное дерево, у которого все листья на одном уровне</p></li>
<li><p>Сбалансированное: дерево, у которого разница между высотой левого и правого поддерева меньше или равна 1</p></li>
</ul>
</dd>
</dl>
<section id="avl">
<h3><strong>В этих таблицах вы можете видеть преимущество AVL деревьев:</strong><a class="headerlink" href="#avl" title="Permalink to this heading"></a></h3>
<img alt="_images/BST_complexity.png" src="_images/BST_complexity.png" />
<img alt="_images/SQT_complexity.png" src="_images/SQT_complexity.png" />
<p><strong>Эти типы деревьев я вынес в отдельные классы</strong></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTree.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">TreeNodeType=&lt;class</span> <span class="pre">'datastructures.binaryTrees.BinaryTreeNode'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTree.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>TreeNodeType</strong> – Тип узлов дерева. По умолчанию <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

</section>
</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">BinaryTreeNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal">
<span class="sig-name descname"><span class="pre">inorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<p>Обход дерева по умолчанию (<a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a>.).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.level_order_traversal">
<span class="sig-name descname"><span class="pre">level_order_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.level_order_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход в ширину (<strong>BFS</strong> - <cite>Breadth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода в ширину:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти следующий слой</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/levelorder-traversal.gif"><img alt="_images/levelorder-traversal.gif" src="_images/levelorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal">
<span class="sig-name descname"><span class="pre">postorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (postorder traversal), также <cite>обратный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм обратного обхода:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/postorder-traversal.gif"><img alt="_images/postorder-traversal.gif" src="_images/postorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal">
<span class="sig-name descname"><span class="pre">preorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (preorder traversal), также <cite>прямой</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм прямого обхода:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/preorder-traversal.gif"><img alt="_images/preorder-traversal.gif" src="_images/preorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла. <em>Высота самого высокого ребёнка + 1</em>.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.BinaryTreeNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.BinaryTreeNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">SQT</span></span><a class="headerlink" href="#datastructures.binaryTrees.SQT" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTree" title="datastructures.binaryTrees.BinaryTree"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTree</span></code></a></p>
<p>Бинарное дерево, к элементам которого можно обращаться по индексу (<em>Sequence Binary Tree</em>).
<strong>Индексация идет по порядку обхода дерева</strong>.</p>
<img alt="_images/SQT_complexity.png" src="_images/SQT_complexity.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>TreeNodeType</strong> – Тип узлов дерева. По умолчанию <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.build">
<span class="sig-name descname"><span class="pre">build</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iterable</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.build" title="Ссылка на это определение"></a></dt>
<dd><p>Построить дерево из входящего списка. Но алгоритм не просто поочерёдно вставлять элементы,
а корнем каждого поддерева является центр среза входящего списка, что способствует балансу дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>iterable</strong> – входящий список</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_at">
<span class="sig-name descname"><span class="pre">delete_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_at" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет i-ый элемент.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс удаляемого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_first">
<span class="sig-name descname"><span class="pre">delete_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_first" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет первый узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.delete_last">
<span class="sig-name descname"><span class="pre">delete_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.delete_last" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет последний узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>значение удаляемого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.get_at">
<span class="sig-name descname"><span class="pre">get_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.get_at" title="Ссылка на это определение"></a></dt>
<dd><p>Получить i-ый узел.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>значение искомого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_at">
<span class="sig-name descname"><span class="pre">insert_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_at" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить новый узел на i-ую позицию.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс нового узла</p></li>
<li><p><strong>data</strong> – значение нового узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_first">
<span class="sig-name descname"><span class="pre">insert_first</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_first" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел в начало дерева (0 позиция).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – значение нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.insert_last">
<span class="sig-name descname"><span class="pre">insert_last</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.insert_last" title="Ссылка на это определение"></a></dt>
<dd><p>Вставляет новый узел в конец дерева (len(self) позиция).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>data</strong> – значение нового узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQT.set_at">
<span class="sig-name descname"><span class="pre">set_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">data</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQT.set_at" title="Ссылка на это определение"></a></dt>
<dd><p>Установить значение i-го узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>i</strong> – индекс узла</p></li>
<li><p><strong>data</strong> – новое значение узла</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">SQTNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode" title="datastructures.binaryTrees.BinaryTreeNode"><code class="xref py py-class docutils literal notranslate"><span class="pre">BinaryTreeNode</span></code></a></p>
<p>Индексируемый узел имеет параметр размера. Размер – это сумма размеров детей + 1.
Это нужно для индексации узлов.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>item</strong> – Значение узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.inorder_traversal">
<span class="sig-name descname"><span class="pre">inorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.inorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<p>Обход дерева по умолчанию (<a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_iter" title="datastructures.binaryTrees.BinaryTreeNode.subtree_iter"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_iter</span></code></a>.).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.level_order_traversal">
<span class="sig-name descname"><span class="pre">level_order_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.level_order_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход в ширину (<strong>BFS</strong> - <cite>Breadth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода в ширину:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти следующий слой</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/levelorder-traversal.gif"><img alt="_images/levelorder-traversal.gif" src="_images/levelorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.maintain">
<span class="sig-name descname"><span class="pre">maintain</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.maintain" title="Ссылка на это определение"></a></dt>
<dd><p>Функция вызывается после удаления или вставки узла (<em>уже прописано в коде</em>).
Она поддерживает дерево сбалансированным за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.rebalance" title="datastructures.binaryTrees.BinaryTreeNode.rebalance"><code class="xref py py-class docutils literal notranslate"><span class="pre">rebalance</span></code></a>
и поддерживает корректность высот у узлов за счёт <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.subtree_update" title="datastructures.binaryTrees.BinaryTreeNode.subtree_update"><code class="xref py py-class docutils literal notranslate"><span class="pre">subtree_update</span></code></a>.
Также оно проходиться вверх по дереву с той же целью.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.postorder_traversal">
<span class="sig-name descname"><span class="pre">postorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.postorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (postorder traversal), также <cite>обратный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.preorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.preorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">preorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм обратного обхода:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/postorder-traversal.gif"><img alt="_images/postorder-traversal.gif" src="_images/postorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.predecessor">
<span class="sig-name descname"><span class="pre">predecessor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.predecessor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти предшественника этого узла (узел, который идёт предыдущий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Предшественник этого узла</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.preorder_traversal">
<span class="sig-name descname"><span class="pre">preorder_traversal</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.preorder_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (preorder traversal), также <cite>прямой</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<p>Смотри также:</p>
<ul class="simple">
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.inorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.inorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">inorder_traversal</span></code></a></p></li>
<li><p><a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.postorder_traversal" title="datastructures.binaryTrees.BinaryTreeNode.postorder_traversal"><code class="xref py py-class docutils literal notranslate"><span class="pre">postorder_traversal</span></code></a></p></li>
</ul>
<dl class="simple">
<dt>Алгоритм прямого обхода:</dt><dd><ol class="arabic simple">
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/preorder-traversal.gif"><img alt="_images/preorder-traversal.gif" src="_images/preorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.rebalance">
<span class="sig-name descname"><span class="pre">rebalance</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.rebalance" title="Ссылка на это определение"></a></dt>
<dd><p>Сбалансировать дерево, если оно слишком накренено:</p>
<ul class="simple">
<li><dl class="simple">
<dt>Если накренено вправо, повернуть налево</dt><dd><ul>
<li><p>Перед этим сбалансировать правое поддерево (<em>повернуть направо</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
<li><dl class="simple">
<dt>Если накренено влево, повернуть направо</dt><dd><ul>
<li><p>Перед этим сбалансировать левое поддерево (<em>повернуть налево</em>) при необходимости</p></li>
</ul>
</dd>
</dl>
</li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.skew">
<span class="sig-name descname"><span class="pre">skew</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.skew" title="Ссылка на это определение"></a></dt>
<dd><p>Найти <em>скос</em> дерева. <em>Скос</em> - это разница между высотами поддеревьев
(<em>в данном случае высота правого минус высота левого</em>). Если эта разница больше нуля, то дерево накренено
<strong>вправо</strong>. Если эта разница меньше нуля, то дерево накренено <strong>влево</strong>. Если эта разница равна нулю,
то дерево <strong>полное</strong> (не накренено).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>разница высот.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_at">
<span class="sig-name descname"><span class="pre">subtree_at</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">i</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_at" title="Ссылка на это определение"></a></dt>
<dd><p>Найти i-ый узел. Поиск происходит через размеры узлов:</p>
<ul class="simple">
<li><p>Если размер левого ребёнка больше индекса, найти i-ый узел в левом поддереве.</p></li>
<li><p>Если размер левого ребёнка меньше индекса, найти узел в правом поддереве с индексом: <em>индекс - размер левого ребёнка - 1</em>.</p></li>
<li><p>Если размер левого ребенка равен индексу, вернуть текущий узел.</p></li>
</ul>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>i</strong> – индекс искомого узла</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>искомый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_delete">
<span class="sig-name descname"><span class="pre">subtree_delete</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_delete" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивная функция удаления узла дерева.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Удаляемый узел</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_first">
<span class="sig-name descname"><span class="pre">subtree_first</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_first" title="Ссылка на это определение"></a></dt>
<dd><p>Получить первый по порядку узел дерева (самый левый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Первый узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_insert_after">
<span class="sig-name descname"><span class="pre">subtree_insert_after</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_insert_after" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) после текущего по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить после текущего</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_insert_before">
<span class="sig-name descname"><span class="pre">subtree_insert_before</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">TreeNodeType</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_insert_before" title="Ссылка на это определение"></a></dt>
<dd><p>Вставить узел (node) перед текущим по порядку.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – Узел, который мы хотим вставить перед текущим</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_iter">
<span class="sig-name descname"><span class="pre">subtree_iter</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_iter" title="Ссылка на это определение"></a></dt>
<dd><p>Рекурсивный обход дерева <cite>по порядку</cite> (in-order traversal), также <cite>центрированный</cite>.
Является одним из трёх обходов в глубину (<strong>DFS</strong> - <cite>Depth First Search</cite>).</p>
<dl class="simple">
<dt>Алгоритм обхода по порядку:</dt><dd><ol class="arabic simple">
<li><p>Обойти левое <em>поддерево</em> (рекурсивно).</p></li>
<li><p><em>Выбросить</em> (оператор yield) <em>корень</em>.</p></li>
<li><p>Обойти правое <em>поддерево</em> (рекурсивно).</p></li>
</ol>
</dd>
</dl>
<a class="reference internal image-reference" href="_images/inorder-traversal.gif"><img alt="_images/inorder-traversal.gif" src="_images/inorder-traversal.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Итерационный объект, состоящий из узлов бинарного дерева по порядку.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_last">
<span class="sig-name descname"><span class="pre">subtree_last</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_last" title="Ссылка на это определение"></a></dt>
<dd><p>Получить последний по порядку узел дерева (самый правый).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Последний узел дерева</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_rotate_left">
<span class="sig-name descname"><span class="pre">subtree_rotate_left</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_left" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева налево нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_left_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать левым ребенком <em>pivot</em>’a корень (<em>root</em>), а правым – <em>pivot_right_subtree</em></p></li>
<li><p>Сделать левым ребёнком <em>root</em>’a <em>root_left_subtree</em>, а правым – <em>pivot_left_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_right_subtree</em> и <em>root_left_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/left_rotation.gif"><img alt="_images/left_rotation.gif" src="_images/left_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_rotate_right">
<span class="sig-name descname"><span class="pre">subtree_rotate_right</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_rotate_right" title="Ссылка на это определение"></a></dt>
<dd><p>Функция поворота дерева направо нужна для поддержки баланса дерева. Она уменьшает скос дерева, не меняя при этом
порядок узлов при обходе дерева по порядку. Функция вызывается относительно корня поддерева,
которое надо повернуть. Функция вызывается при каждом обновлении дерева, см. <a class="reference internal" href="#datastructures.binaryTrees.BinaryTreeNode.maintain" title="datastructures.binaryTrees.BinaryTreeNode.maintain"><code class="xref py py-class docutils literal notranslate"><span class="pre">maintain</span></code></a>.</p>
<p><strong>Алгоритм:</strong></p>
<ol class="arabic simple">
<li><p>Обозначить временные переменные для хранения узлов: <em>root_right_subtree</em>, <em>pivot_left_subtree</em>, <em>pivot_right_subtree</em></p></li>
<li><p>Поменять местами корень (<em>root</em>) и опорную точку (<em>pivot</em>). Теперь <em>pivot</em> - корень</p></li>
<li><p>Сделать правым ребенком <em>pivot</em>’a корень (<em>root</em>), а левым – <em>pivot_left_subtree</em></p></li>
<li><p>Сделать правым ребёнком <em>root</em>’a <em>root_right_subtree</em>, а левым – <em>pivot_right_subtree</em></p></li>
<li><p>Не забыть поставить указатели на своих родителей для <em>pivot_left_subtree</em> и <em>root_right_subtree</em></p></li>
<li><p>Обновить дерево относительно <em>pivot</em>’a и <em>root</em>’a</p></li>
</ol>
<a class="reference internal image-reference" href="_images/right_rotation.gif"><img alt="_images/right_rotation.gif" src="_images/right_rotation.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.subtree_update">
<span class="sig-name descname"><span class="pre">subtree_update</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.subtree_update" title="Ссылка на это определение"></a></dt>
<dd><p>Обновляет высоту узла (<em>высота самого высокого ребёнка + 1</em>)
и размер (<em>это сумма размеров детей + 1</em>).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.binaryTrees.SQTNode.successor">
<span class="sig-name descname"><span class="pre">successor</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.binaryTrees.SQTNode.successor" title="Ссылка на это определение"></a></dt>
<dd><p>Найти преемника этого узла (узел, который идёт следующий по порядку).</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), <em>(если дерево не сбалансировано - O(h))</em></p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Преемник этого узла</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.binaryTrees.height">
<span class="sig-prename descclassname"><span class="pre">datastructures.binaryTrees.</span></span><span class="sig-name descname"><span class="pre">height</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">node</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#datastructures.binaryTrees.height" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает высоту входящего узла. Сложность алгоритма является <strong>O(1)</strong>
вместо O(h), потому что каждый узел хранит в себе значение его высоты.
При каждом изменении дерева это значение обновляется при необходимости.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>node</strong> – узел, высоту которого надо узнать</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>высота узла и, если узла нет, -1</p>
</dd>
</dl>
</dd></dl>

</section>
<section id="module-datastructures.heap">
<span id="datastructures-heap-module"></span><h2>datastructures.heap module<a class="headerlink" href="#module-datastructures.heap" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.heap.</span></span><span class="sig-name descname"><span class="pre">MinHeap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Куча минимума - это бинарное дерево, где ключ каждого узла всегда меньше или равен ключам его детей.
Эта структура данных позволяет эффективно вставлять, удалять и находить минимальный элемент в куче.</p>
<img alt="_images/heap.png" src="_images/heap.png" />
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализировать новую кучу минимума.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(N log N), где n - количество элементов в arr.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr</strong> – Необязательный итерируемый объект, содержащий начальные элементы кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.add" title="Ссылка на это определение"></a></dt>
<dd><p>Добавляет элемент в кучу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Элемент для добавления.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.count" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает количество вхождений указанного элемента в кучу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Элемент для подсчета.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Количество вхождений элемента в кучу.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.get_item">
<span class="sig-name descname"><span class="pre">get_item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.get_item" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает элемент по указанному индексу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс элемента для возврата.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Элемент по указанному индексу.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.get_left_child_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_left_child_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.get_left_child_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс левого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс левого потомка узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.get_parent_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_parent_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.get_parent_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс родителя указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс родителя узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.get_right_child_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_right_child_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.get_right_child_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс правого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс правого потомка узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.has_left_child">
<span class="sig-name descname"><span class="pre">has_left_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.MinHeap.has_left_child" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла левый потомок.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет левого потомка, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.has_parent">
<span class="sig-name descname"><span class="pre">has_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.MinHeap.has_parent" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла родитель.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет родителя, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.has_right_child">
<span class="sig-name descname"><span class="pre">has_right_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.MinHeap.has_right_child" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла правый потомок.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет правого потомка, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.heapify_down">
<span class="sig-name descname"><span class="pre">heapify_down</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.heapify_down" title="Ссылка на это определение"></a></dt>
<dd><p>Перестраивает элементы в куче вниз от указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла для начала. Если не указан, используется корень кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.heapify_up">
<span class="sig-name descname"><span class="pre">heapify_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.heapify_up" title="Ссылка на это определение"></a></dt>
<dd><p>Перестраивает элементы в куче вверх от указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла для начала. Если не указан, используется последний элемент кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.left_child">
<span class="sig-name descname"><span class="pre">left_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.left_child" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает левого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Левый потомок узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.parent" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает родителя указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Родитель узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.peek">
<span class="sig-name descname"><span class="pre">peek</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.peek" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает минимальный элемент в куче без его удаления.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Минимальный элемент в куче.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.poll">
<span class="sig-name descname"><span class="pre">poll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.poll" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет и возвращает минимальный элемент из кучи.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс элемента для удаления. Если не указан, удаляется минимальный элемент.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Минимальный элемент в куче.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.MinHeap.right_child">
<span class="sig-name descname"><span class="pre">right_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.MinHeap.right_child" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает правого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Правый потомок узла.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.heap.</span></span><span class="sig-name descname"><span class="pre">PriorityQueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.heap.MinHeap" title="datastructures.heap.MinHeap"><code class="xref py py-class docutils literal notranslate"><span class="pre">MinHeap</span></code></a></p>
<p>Приоритетная очередь, реализованная на основе мин-кучи.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">arr</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализировать новую кучу минимума.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(N log N), где n - количество элементов в arr.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>arr</strong> – Необязательный итерируемый объект, содержащий начальные элементы кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.add">
<span class="sig-name descname"><span class="pre">add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.add" title="Ссылка на это определение"></a></dt>
<dd><p>Добавляет элемент в кучу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Элемент для добавления.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.count">
<span class="sig-name descname"><span class="pre">count</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.count" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает количество вхождений указанного элемента в кучу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>item</strong> – Элемент для подсчета.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Количество вхождений элемента в кучу.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.dequeue">
<span class="sig-name descname"><span class="pre">dequeue</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.dequeue" title="Ссылка на это определение"></a></dt>
<dd><p>Извлекает и возвращает элемент с наивысшим приоритетом из приоритетной очереди.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Самый приоритетный узел.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.enqueue">
<span class="sig-name descname"><span class="pre">enqueue</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">item</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priority</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.enqueue" title="Ссылка на это определение"></a></dt>
<dd><p>Добавляет элемент в приоритетную очередь с указанным приоритетом.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n)</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>item</strong> – Элемент для добавления.</p></li>
<li><p><strong>priority</strong> – Приоритет элемента. (По умолчанию 0 – самый высокий приоритет)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.get_item">
<span class="sig-name descname"><span class="pre">get_item</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.get_item" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает элемент по указанному индексу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс элемента для возврата.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Элемент по указанному индексу.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.get_left_child_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_left_child_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.get_left_child_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс левого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс левого потомка узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.get_parent_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_parent_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.get_parent_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс родителя указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс родителя узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.get_right_child_index">
<em class="property"><span class="pre">static</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">get_right_child_index</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.get_right_child_index" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает индекс правого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Индекс правого потомка узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.has_left_child">
<span class="sig-name descname"><span class="pre">has_left_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.PriorityQueue.has_left_child" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла левый потомок.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет левого потомка, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.has_parent">
<span class="sig-name descname"><span class="pre">has_parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.PriorityQueue.has_parent" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла родитель.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет родителя, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.has_right_child">
<span class="sig-name descname"><span class="pre">has_right_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#datastructures.heap.PriorityQueue.has_right_child" title="Ссылка на это определение"></a></dt>
<dd><p>Проверяет, есть ли у указанного узла правый потомок.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>True, если узел имеет правого потомка, иначе False.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.heapify_down">
<span class="sig-name descname"><span class="pre">heapify_down</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.heapify_down" title="Ссылка на это определение"></a></dt>
<dd><p>Перестраивает элементы в куче вниз от указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла для начала. Если не указан, используется корень кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.heapify_up">
<span class="sig-name descname"><span class="pre">heapify_up</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.heapify_up" title="Ссылка на это определение"></a></dt>
<dd><p>Перестраивает элементы в куче вверх от указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла для начала. Если не указан, используется последний элемент кучи.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.left_child">
<span class="sig-name descname"><span class="pre">left_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.left_child" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает левого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Левый потомок узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.parent">
<span class="sig-name descname"><span class="pre">parent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.parent" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает родителя указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Родитель узла.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.peek">
<span class="sig-name descname"><span class="pre">peek</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.peek" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает минимальный элемент в куче без его удаления.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>Минимальный элемент в куче.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.poll">
<span class="sig-name descname"><span class="pre">poll</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.poll" title="Ссылка на это определение"></a></dt>
<dd><p>Удаляет и возвращает минимальный элемент из кучи.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(log n), где n - количество элементов в куче.</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс элемента для удаления. Если не указан, удаляется минимальный элемент.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Минимальный элемент в куче.</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueue.right_child">
<span class="sig-name descname"><span class="pre">right_child</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">index</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueue.right_child" title="Ссылка на это определение"></a></dt>
<dd><p>Возвращает правого потомка указанного узла.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(1).</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>index</strong> – Индекс узла.</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>Правый потомок узла.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueueNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.heap.</span></span><span class="sig-name descname"><span class="pre">PriorityQueueNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priority</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueueNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Узел приоритетной очереди.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.heap.PriorityQueueNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">val</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">priority</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.heap.PriorityQueueNode.__init__" title="Ссылка на это определение"></a></dt>
<dd></dd></dl>

</dd></dl>

</section>
<section id="module-datastructures.graphs">
<span id="datastructures-graphs-module"></span><h2>datastructures.graphs module<a class="headerlink" href="#module-datastructures.graphs" title="Permalink to this heading"></a></h2>
<dl class="py class">
<dt class="sig sig-object py" id="datastructures.graphs.GraphNode">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.graphs.</span></span><span class="sig-name descname"><span class="pre">GraphNode</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphNode" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<p>Узел графа. Нужен для реализации графа через <em>связанный список</em></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphNode.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphNode.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v2</strong> – куда</p></li>
<li><p><strong>weight</strong> – вес</p></li>
</ul>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.graphs.</span></span><span class="sig-name descname"><span class="pre">GraphParent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <code class="xref py py-class docutils literal notranslate"><span class="pre">object</span></code></p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Создает пустой граф.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – количество узлов / размер графа</p></li>
<li><p><strong>directed</strong> – направленный / ненаправленный граф</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.add_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Добавить грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
<li><p><strong>weight</strong> – вес грани (его значение)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.breadth_first_traversal">
<span class="sig-name descname"><span class="pre">breadth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.breadth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в ширину. (<em>BFT – Breadth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-bfs.gif"><img alt="_images/graph-bfs.gif" src="_images/graph-bfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.depth_first_traversal">
<span class="sig-name descname"><span class="pre">depth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.depth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в глубину. (<em>DFT – Depth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-dfs.gif"><img alt="_images/graph-dfs.gif" src="_images/graph-dfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.print_adjacency">
<span class="sig-name descname"><span class="pre">print_adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.print_adjacency" title="Ссылка на это определение"></a></dt>
<dd><p>Вывести в консоль список / матрицу смежности.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#datastructures.graphs.GraphParent.remove_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Убрать грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
</ul>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>вес удалённой грани</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.shortest_path">
<span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_node:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">(&lt;class</span> <span class="pre">'int'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'list'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.shortest_path" title="Ссылка на это определение"></a></dt>
<dd><p>Алгоритм Дейкстры. Находит самый короткий путь между двумя узлами.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V<sup>2</sup>), где V - количество вершин</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – индекс первого узла (откуда проложить маршрут)</p></li>
<li><p><strong>to_node</strong> – индекс второго узла (куда проложить маршрут)</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple (int, list)
- Первый элемент – это минимальная длина маршрута
- Второй элемент – это кратчайший маршрут: последовательность индексов, которые нужно посетить</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.GraphParent.traversal">
<span class="sig-name descname"><span class="pre">traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_type:</span> <span class="pre">object</span> <span class="pre">=</span> <span class="pre">&lt;class</span> <span class="pre">'datastructures.linearDataStructures.Queue'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.GraphParent.traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Проходка по графу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p></li>
<li><p><strong>storage_type</strong> – структура, для управления узлами: очередь – если в ширину, стэк – если в глубину</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.graphs.</span></span><span class="sig-name descname"><span class="pre">ListAdjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.graphs.GraphParent" title="datastructures.graphs.GraphParent"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphParent</span></code></a></p>
<p>Реализация графа через список смежности.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Создает пустой граф.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – количество узлов / размер графа</p></li>
<li><p><strong>directed</strong> – направленный / ненаправленный граф</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.add_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Добавить грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
<li><p><strong>weight</strong> – вес грани (его значение)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.breadth_first_traversal">
<span class="sig-name descname"><span class="pre">breadth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.breadth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в ширину. (<em>BFT – Breadth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-bfs.gif"><img alt="_images/graph-bfs.gif" src="_images/graph-bfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.depth_first_traversal">
<span class="sig-name descname"><span class="pre">depth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.depth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в глубину. (<em>DFT – Depth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-dfs.gif"><img alt="_images/graph-dfs.gif" src="_images/graph-dfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.print_adjacency">
<span class="sig-name descname"><span class="pre">print_adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.print_adjacency" title="Ссылка на это определение"></a></dt>
<dd><p>Вывести в консоль список смежности.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.remove_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Убрать грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
</ul>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>вес удалённой грани</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.shortest_path">
<span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_node:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">(&lt;class</span> <span class="pre">'int'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'list'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.shortest_path" title="Ссылка на это определение"></a></dt>
<dd><p>Алгоритм Дейкстры. Находит самый короткий путь между двумя узлами.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V<sup>2</sup>), где V - количество вершин</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – индекс первого узла (откуда проложить маршрут)</p></li>
<li><p><strong>to_node</strong> – индекс второго узла (куда проложить маршрут)</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple (int, list)
- Первый элемент – это минимальная длина маршрута
- Второй элемент – это кратчайший маршрут: последовательность индексов, которые нужно посетить</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.ListAdjacency.traversal">
<span class="sig-name descname"><span class="pre">traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.ListAdjacency.traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Проходка по графу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p></li>
<li><p><strong>storage_type</strong> – структура, для управления узлами: очередь – если в ширину, стэк – если в глубину</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">datastructures.graphs.</span></span><span class="sig-name descname"><span class="pre">MatrixAdjacency</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency" title="Ссылка на это определение"></a></dt>
<dd><p>Базовые классы: <a class="reference internal" href="#datastructures.graphs.GraphParent" title="datastructures.graphs.GraphParent"><code class="xref py py-class docutils literal notranslate"><span class="pre">GraphParent</span></code></a></p>
<p>Реализация графа через матрицу смежности.</p>
<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">size</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">directed</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.__init__" title="Ссылка на это определение"></a></dt>
<dd><p>Инициализатор. Создает пустой граф.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>size</strong> – количество узлов / размер графа</p></li>
<li><p><strong>directed</strong> – направленный / ненаправленный граф</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.add_edge">
<span class="sig-name descname"><span class="pre">add_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">weight</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.add_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Добавить грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
<li><p><strong>weight</strong> – вес грани (его значение)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.breadth_first_traversal">
<span class="sig-name descname"><span class="pre">breadth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.breadth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в ширину. (<em>BFT – Breadth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-bfs.gif"><img alt="_images/graph-bfs.gif" src="_images/graph-bfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.depth_first_traversal">
<span class="sig-name descname"><span class="pre">depth_first_traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.depth_first_traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Обход графа в глубину. (<em>DFT – Depth First Traversal</em>).</p>
<a class="reference internal image-reference" href="_images/graph-dfs.gif"><img alt="_images/graph-dfs.gif" src="_images/graph-dfs.gif" style="width: 400px;" /></a>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.print_adjacency">
<span class="sig-name descname"><span class="pre">print_adjacency</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.print_adjacency" title="Ссылка на это определение"></a></dt>
<dd><p>Вывести матрицу в консоль.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.remove_edge">
<span class="sig-name descname"><span class="pre">remove_edge</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">v1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">v2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">repeat</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.remove_edge" title="Ссылка на это определение"></a></dt>
<dd><p>Убрать грань.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>v1</strong> – номер 1го узла</p></li>
<li><p><strong>v2</strong> – номер 2го узла</p></li>
<li><p><strong>repeat</strong> – служебная переменная для избегания бесконечной рекурсии, используется для ненаправленных графов</p></li>
</ul>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>вес удалённой грани</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.shortest_path">
<span class="sig-name descname"><span class="pre">shortest_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">to_node:</span> <span class="pre">int)</span> <span class="pre">-&gt;</span> <span class="pre">(&lt;class</span> <span class="pre">'int'&gt;</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">&lt;class</span> <span class="pre">'list'&gt;</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.shortest_path" title="Ссылка на это определение"></a></dt>
<dd><p>Алгоритм Дейкстры. Находит самый короткий путь между двумя узлами.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V<sup>2</sup>), где V - количество вершин</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – индекс первого узла (откуда проложить маршрут)</p></li>
<li><p><strong>to_node</strong> – индекс второго узла (куда проложить маршрут)</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>tuple (int, list)
- Первый элемент – это минимальная длина маршрута
- Второй элемент – это кратчайший маршрут: последовательность индексов, которые нужно посетить</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="datastructures.graphs.MatrixAdjacency.traversal">
<span class="sig-name descname"><span class="pre">traversal</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">from_node</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">storage_type</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#datastructures.graphs.MatrixAdjacency.traversal" title="Ссылка на это определение"></a></dt>
<dd><p>Проходка по графу.</p>
<dl class="field-list simple">
<dt class="field-odd">Сложность<span class="colon">:</span></dt>
<dd class="field-odd"><p>O(V + E), где V – количество вершин и E – количество рёбер</p>
</dd>
<dt class="field-even">Параметры<span class="colon">:</span></dt>
<dd class="field-even"><ul class="simple">
<li><p><strong>from_node</strong> – номер узла, от которого идёт проходка</p></li>
<li><p><strong>storage_type</strong> – структура, для управления узлами: очередь – если в ширину, стэк – если в глубину</p></li>
</ul>
</dd>
<dt class="field-odd">Результат<span class="colon">:</span></dt>
<dd class="field-odd"><p>итерационный объект с номерами узлов</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py function">
<dt class="sig sig-object py" id="datastructures.graphs.get_path">
<span class="sig-prename descclassname"><span class="pre">datastructures.graphs.</span></span><span class="sig-name descname"><span class="pre">get_path</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">prev_nodes</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">list</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">list</span></span></span><a class="headerlink" href="#datastructures.graphs.get_path" title="Ссылка на это определение"></a></dt>
<dd><p>Находит путь до цели, используя список из индексов предыдущих узлов.</p>
<dl class="field-list simple">
<dt class="field-odd">Параметры<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>prev_nodes</strong> – список из индексов предыдущих узлов</p></li>
<li><p><strong>target</strong> – целевой узел, до которого мы вычисляем путь</p></li>
</ul>
</dd>
<dt class="field-even">Результат<span class="colon">:</span></dt>
<dd class="field-even"><p>список – последовательность индексов узлов</p>
</dd>
</dl>
</dd></dl>

</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Нижняя область">
        <a href="index.html" class="btn btn-neutral float-left" title="Welcome to Python DataStructures by slav_EEik documentation!" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Предыдущая</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Авторские права 2023, zhukovrost. </p>
  </div>

  Собрано при помощи <a href="https://www.sphinx-doc.org/">Sphinx</a> с использованием
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">темы,</a>
    предоставленной <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>